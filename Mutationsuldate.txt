-- üëÜ GUI appears BEFORE Rayfield loading UI starts

task.defer(function()
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")

    local player = Players.LocalPlayer
    local PlayerGui = player:WaitForChild("PlayerGui")

    local discordLink = "https://discord.gg/C5N4Y4cqqN"

    local translations = {
        ["en"] = { join = "Join our Discord!", copy = "Copy Link", copied = "Copied Discord Link!" },
        ["ar"] = { join = "ÿßŸÜÿ∂ŸÖ ÿ•ŸÑŸâ ÿØŸäÿ≥ŸÉŸàÿ±ÿØŸÜÿß!", copy = "ŸÜÿ≥ÿÆ ÿßŸÑÿ±ÿßÿ®ÿ∑", copied = "ÿ™ŸÖ ŸÜÿ≥ÿÆ ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿØŸäÿ≥ŸÉŸàÿ±ÿØ!" },
        ["fil"] = { join = "Sumali sa aming Discord!", copy = "Kopyahin ang Link", copied = "Nai-copy ang Discord Link!" },
        ["pt"] = { join = "Junte-se ao nosso Discord!", copy = "Copiar Link", copied = "Link do Discord copiado!" },
        ["es"] = { join = "¬°√önete a nuestro Discord!", copy = "Copiar enlace", copied = "¬°Enlace de Discord copiado!" },
        ["fr"] = { join = "Rejoignez notre Discord !", copy = "Copier le lien", copied = "Lien Discord copi√© !" },
        ["ru"] = { join = "–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ –Ω–∞—à–µ–º—É Discord!", copy = "–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É", copied = "–°—Å—ã–ª–∫–∞ Discord —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!" },
    }

    local locale = player.LocaleId:sub(1,2):lower()
    local texts = translations[locale] or translations["en"]

    local function rainbowColor(t)
        local r = (math.sin(t) * 0.5 + 0.5)
        local g = (math.sin(t + 2 * math.pi / 3) * 0.5 + 0.5)
        local b = (math.sin(t + 4 * math.pi / 3) * 0.5 + 0.5)
        return Color3.new(r, g, b)
    end

    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "DiscordInviteGUI"
    ScreenGui.IgnoreGuiInset = true
    ScreenGui.ResetOnSpawn = false
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ScreenGui.DisplayOrder = 999
    ScreenGui.Parent = PlayerGui

    local Frame = Instance.new("Frame")
    Frame.Size = UDim2.new(0, 320, 0, 110)
    Frame.Position = UDim2.new(0.5, -160, 0.05, 0)
    Frame.BackgroundColor3 = Color3.fromRGB(54, 57, 63)
    Frame.BackgroundTransparency = 1
    Frame.BorderSizePixel = 0
    Frame.AnchorPoint = Vector2.new(0.5, 0)
    Frame.ClipsDescendants = true
    Frame.Active = true
    Frame.Draggable = true
    Frame.ZIndex = 100
    Frame.Parent = ScreenGui

    Instance.new("UICorner", Frame).CornerRadius = UDim.new(0, 20)

    local Glow = Instance.new("Frame", Frame)
    Glow.Size = UDim2.new(1, 14, 1, 14)
    Glow.Position = UDim2.new(0, -7, 0, -7)
    Glow.BackgroundTransparency = 1
    Glow.ZIndex = 99

    local GlowStroke = Instance.new("UIStroke", Glow)
    GlowStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    GlowStroke.Thickness = 4
    GlowStroke.Transparency = 0
    GlowStroke.Color = Color3.fromRGB(255, 0, 0)

    Instance.new("UICorner", Glow).CornerRadius = UDim.new(0, 20)

    local TitleLabel = Instance.new("TextLabel", Frame)
    TitleLabel.Size = UDim2.new(1, -20, 0, 30)
    TitleLabel.Position = UDim2.new(0, 10, 0, 10)
    TitleLabel.BackgroundTransparency = 1
    TitleLabel.Text = texts.join
    TitleLabel.Font = Enum.Font.GothamBold
    TitleLabel.TextSize = 22
    TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    TitleLabel.TextXAlignment = Enum.TextXAlignment.Center
    TitleLabel.TextTransparency = 1
    TitleLabel.ZIndex = 101

    local CopyButton = Instance.new("TextButton", Frame)
    CopyButton.Size = UDim2.new(0, 150, 0, 45)
    CopyButton.Position = UDim2.new(0.5, -75, 0, 55)
    CopyButton.BackgroundColor3 = Color3.fromRGB(88, 101, 242)
    CopyButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    CopyButton.TextSize = 18
    CopyButton.Font = Enum.Font.GothamSemibold
    CopyButton.Text = texts.copy
    CopyButton.AutoButtonColor = true
    CopyButton.BorderSizePixel = 0
    CopyButton.BackgroundTransparency = 1
    CopyButton.TextTransparency = 1
    CopyButton.ZIndex = 101
    Instance.new("UICorner", CopyButton).CornerRadius = UDim.new(0, 15)

    TweenService:Create(Frame, TweenInfo.new(1), {BackgroundTransparency = 0.1}):Play()
    TweenService:Create(TitleLabel, TweenInfo.new(1), {TextTransparency = 0}):Play()
    TweenService:Create(CopyButton, TweenInfo.new(1), {BackgroundTransparency = 0, TextTransparency = 0}):Play()

    local start = tick()
    game:GetService("RunService").Heartbeat:Connect(function()
        local t = tick() - start
        GlowStroke.Color = rainbowColor(t * 2)
    end)

    local function fadeOut()
        TweenService:Create(Frame, TweenInfo.new(1), {BackgroundTransparency = 1}):Play()
        TweenService:Create(TitleLabel, TweenInfo.new(1), {TextTransparency = 1}):Play()
        TweenService:Create(CopyButton, TweenInfo.new(1), {BackgroundTransparency = 1, TextTransparency = 1}):Play()
        task.delay(1, function()
            ScreenGui:Destroy()
        end)
    end

    CopyButton.MouseButton1Click:Connect(function()
        if setclipboard then setclipboard(discordLink) end
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Discord",
                Text = texts.copied,
                Duration = 3,
                Icon = "rbxassetid://13412031254"
            })
        end)
        fadeOut()
    end)

    task.delay(10, fadeOut)
end)

-- GUI with Draggable Circular ImageButton to simulate pressing K key
local ScreenGui = Instance.new("ScreenGui")
local KButton = Instance.new("ImageButton")

-- Parent GUI to CoreGui (requires exploit environment like Synapse)
ScreenGui.Name = "KKeyGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = game:GetService("CoreGui")

-- Configure circular image button (11% smaller than 78 ‚Üí ~69px)
KButton.Parent = ScreenGui
KButton.Size = UDim2.new(0, 69, 0, 69)
KButton.Position = UDim2.new(0, 40, 0.4, -34)
KButton.BackgroundTransparency = 1
KButton.Image = "rbxassetid://139349233430103"
KButton.ScaleType = Enum.ScaleType.Fit
KButton.ClipsDescendants = true

-- Make it circular
local corner = Instance.new("UICorner", KButton)
corner.CornerRadius = UDim.new(1, 0)

-- Draggable (supports both Mouse & Touch)
local dragging = false
local dragStart, startPos

local function inputPosition(input)
	return input.Position or input.TouchPosition or Vector2.zero
end

KButton.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = inputPosition(input)
		startPos = KButton.Position

		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)

game:GetService("UserInputService").InputChanged:Connect(function(input)
	if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
		local delta = inputPosition(input) - dragStart
		KButton.Position = UDim2.new(
			startPos.X.Scale,
			startPos.X.Offset + delta.X,
			startPos.Y.Scale,
			startPos.Y.Offset + delta.Y
		)
	end
end)

-- Simulate pressing the K key
KButton.MouseButton1Click:Connect(function()
	local vim = game:GetService("VirtualInputManager")
	vim:SendKeyEvent(true, Enum.KeyCode.K, false, game)  -- Key down
	vim:SendKeyEvent(false, Enum.KeyCode.K, false, game) -- Key up
end)


local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

-- Create the main window
local Window = Rayfield:CreateWindow({
Name = "Steal a Brain Rot Destroyer v2 Ken Hub",
LoadingTitle = "made by ken_i",
LoadingSubtitle = "Using Rayfield",
ConfigurationSaving = { Enabled = true },
Discord = { Enabled = false },
KeySystem = false
})

pcall(function()
   loadstring(game:HttpGet("https://pastebin.com/raw/MWYTEiiy", true))()
end)

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- Core variables
local speedLockEnabled = false
local visibilityEnabled = false
local antiTrapEnabled = false
local antiTrapRunning = false
local medusaEnabled = false
local medusaCooldown = false
local medusaToolName = "Medusa's Head"
local medusaRange = 16
local sentryActive = false
local shopNPCCashActive = false
local originalShopPositions = {}

-- ShopNPCCash functionality
local function manageShopNPCCash()
while shopNPCCashActive and task.wait(0.1) do
local cashModel = workspace:FindFirstChild("ShopNPCCash")
local character = LocalPlayer.Character
local rootPart = character and character:FindFirstChild("HumanoidRootPart")

if cashModel and cashModel:IsA("Model") and rootPart then
-- Store original position if not already stored
if not originalShopPositions[cashModel] then
local primaryPart = cashModel.PrimaryPart or cashModel:FindFirstChildWhichIsA("BasePart")
if primaryPart then
originalShopPositions[cashModel] = primaryPart.CFrame
end
end

-- Prepare and move the model
local primaryPart = cashModel.PrimaryPart or cashModel:FindFirstChildWhichIsA("BasePart")
if primaryPart then
for _, part in ipairs(cashModel:GetDescendants()) do
if part:IsA("BasePart") then
part.Anchored = false
part.CanCollide = false
part.Massless = true
end
end
cashModel:SetPrimaryPartCFrame(rootPart.CFrame * CFrame.new(0, 0, -3))
end
end
end

-- Return shops to original positions when disabled
if not shopNPCCashActive then
for model, position in pairs(originalShopPositions) do
if model and model.Parent then
local primaryPart = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
if primaryPart then
model:SetPrimaryPartCFrame(position)
for _, part in ipairs(model:GetDescendants()) do
if part:IsA("BasePart") then
part.Anchored = true
part.CanCollide = true
part.Massless = false
end
end
end
end
end
originalShopPositions = {}
end
end

-- Visibility functionality
local function makeCharacterVisible(character)
for _, part in ipairs(character:GetDescendants()) do
if part:IsA("BasePart") then
part.Transparency = 0
part.CanCollide = false
elseif part:IsA("Accessory") or part:IsA("Tool") then
local handle = part:FindFirstChild("Handle")
if handle and handle:IsA("BasePart") then
handle.Transparency = 0
handle.CanCollide = false
end
end
end
end

local function makeToolsVisible(player)
local backpack = player:FindFirstChild("Backpack")
if backpack then
for _, tool in ipairs(backpack:GetChildren()) do
local handle = tool:FindFirstChild("Handle")
if handle and handle:IsA("BasePart") then
handle.Transparency = 0
handle.CanCollide = false
end
end
end
if player.Character then
for _, tool in ipairs(player.Character:GetChildren()) do
local handle = tool:FindFirstChild("Handle")
if handle and handle:IsA("BasePart") then
handle.Transparency = 0
handle.CanCollide = false
end
end
end
end

local function onCharacterAdded(character)
makeCharacterVisible(character)
character.ChildAdded:Connect(function(child)
task.wait(0.1)
if child:IsA("BasePart") then
child.Transparency = 0
child.CanCollide = true
elseif child:IsA("Accessory") or child:IsA("Tool") then
local handle = child:FindFirstChild("Handle")
if handle and handle:IsA("BasePart") then
handle.Transparency = 0
handle.CanCollide = false
end
end
end)
end

-- Speed lock
local function applySpeedProtection(humanoid)
if not humanoid then return end
humanoid.WalkSpeed = desiredSpeed
humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
if speedLockEnabled and humanoid.WalkSpeed ~= desiredSpeed then
humanoid.WalkSpeed = desiredSpeed
end
end)
end

-- Character listener
local function onPlayerCharacterAdded(character)
local humanoid = character:WaitForChild("Humanoid", 5)
if humanoid and speedLockEnabled then
applySpeedProtection(humanoid)
end
if visibilityEnabled then
onCharacterAdded(character)
end
end

LocalPlayer.CharacterAdded:Connect(onPlayerCharacterAdded)
if LocalPlayer.Character then onPlayerCharacterAdded(LocalPlayer.Character) end

-- Fake trap creation
local function getAveragePosition(obj)
if obj:IsA("Model") then
local total = Vector3.zero
local count = 0
for _, part in ipairs(obj:GetDescendants()) do
if part:IsA("BasePart") then
total += part.Position
count += 1
end
end
if count > 0 then return total / count end
elseif obj:IsA("BasePart") then
return obj.Position
end
return Vector3.zero
end

local function createFakeTrap(position)
local part = Instance.new("Part")
part.Name = "FakeTrap"
part.Size = Vector3.new(1.3,1.3,1.3)
part.Anchored = true
part.CanCollide = false
part.Color = Color3.fromRGB(0,255,0)
part.Material = Enum.Material.SmoothPlastic
part.Position = position + Vector3.new(0, part.Size.Y/2, 0)
part.Parent = workspace
end

local function startAntiTrap()
if antiTrapRunning then return end
antiTrapRunning = true
task.spawn(function()
while antiTrapEnabled do
for _, obj in ipairs(workspace:GetDescendants()) do
if obj.Name == "Trap" then
local pos = getAveragePosition(obj)
pcall(function() obj:Destroy() end)
createFakeTrap(pos)
end
end
task.wait(5)
end
antiTrapRunning = false
end)
end

-- Medusa logic
local function activateMedusa()
if medusaCooldown then return end
local char = LocalPlayer.Character
if not char then return end
local humanoid = char:FindFirstChildOfClass("Humanoid")
if not humanoid then return end
local equipped = char:FindFirstChild(medusaToolName)
if equipped then
equipped:Activate()
else
local tool = LocalPlayer.Backpack:FindFirstChild(medusaToolName)
if tool then
humanoid:EquipTool(tool)
task.wait(0.00001)
tool:Activate()
end
end
medusaCooldown = true
task.delay(0.006, function() medusaCooldown = false end)
end

-- Sentry grab logic
RunService.Heartbeat:Connect(function()
if not sentryActive then return end

local char = LocalPlayer.Character
if not char then return end
local tool = char:FindFirstChildOfClass("Tool")
local handle = tool and tool:FindFirstChild("Handle")
if not handle then return end

for _, part in ipairs(workspace:GetDescendants()) do
if part:IsA("BasePart") and part.Name:find("Sentry_") then
local dist = (part.Position - handle.Position).Magnitude
if dist <= 70 then
part.Massless = true
part.CanCollide = false
part.Anchored = false
part.CFrame = handle.CFrame
end
end
end
end)

-- UI Setup
local MainTab = Window:CreateTab("üöπ Main", 6034818371)
-- Below your Rayfield window and MainTab setup

local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local isHeavy = false
local normalProps = {}
local heavyDensity = 15

-- Function to toggle heaviness
local function setHeaviness(enable)
	isHeavy = enable
	local character = player.Character
	if not character then return end

	for _, part in ipairs(character:GetDescendants()) do
		if part:IsA("BasePart") and not part.Massless then
			if enable then
				normalProps[part] = part.CustomPhysicalProperties or PhysicalProperties.new()
				part.CustomPhysicalProperties = PhysicalProperties.new(
					heavyDensity,
					normalProps[part].Friction,
					normalProps[part].Elasticity,
					normalProps[part].FrictionWeight,
					normalProps[part].ElasticityWeight
				)
			elseif normalProps[part] then
				part.CustomPhysicalProperties = normalProps[part]
			end
		end
	end
end

-- Reapply on respawn
player.CharacterAdded:Connect(function(char)
	character = char
	normalProps = {}
	if isHeavy then
		setHeaviness(true)
	end
end)

-- üí¢ Rayfield Toggle for Less Knock Back
MainTab:CreateToggle({
	Name = "üí¢ Anti Ragdoll",
	CurrentValue = false,
	Callback = function(enabled)
		setHeaviness(enabled)
	end
})

local Players = game:GetService("Players")
local player = Players.LocalPlayer

local guiRef = nil
local toggleEnabled = false

local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- GUI creation
local gui = Instance.new("ScreenGui")
gui.Name = "UpTeleportGUI"
gui.ResetOnSpawn = false
gui.Enabled = false
gui.Parent = player:WaitForChild("PlayerGui")

local buttonHolder = Instance.new("Frame")
buttonHolder.Size = UDim2.new(0, 180, 0, 60)
buttonHolder.Position = UDim2.new(1, -20, 0, 10)
buttonHolder.AnchorPoint = Vector2.new(1, 0)
buttonHolder.BackgroundColor3 = Color3.new(0, 0, 0)
buttonHolder.BackgroundTransparency = 0.2
buttonHolder.BorderSizePixel = 0
buttonHolder.Active = true
buttonHolder.Draggable = true
buttonHolder.ZIndex = 3
buttonHolder.Parent = gui

Instance.new("UICorner", buttonHolder).CornerRadius = UDim.new(0, 16)

local upButton = Instance.new("TextButton")
upButton.Size = UDim2.new(1, -40, 1, -20)
upButton.Position = UDim2.new(0, 20, 0, 10)
upButton.Text = "‚¨ÜTp Up"
upButton.BackgroundColor3 = Color3.fromRGB(0, 200, 100)
upButton.TextColor3 = Color3.new(1, 1, 1)
upButton.Font = Enum.Font.SourceSansBold
upButton.TextSize = 22
upButton.BorderSizePixel = 0
upButton.ZIndex = 4
upButton.Parent = buttonHolder

Instance.new("UICorner", upButton).CornerRadius = UDim.new(0, 12)

upButton.MouseButton1Click:Connect(function()
    local character = player.Character or player.CharacterAdded:Wait()
    local root = character:FindFirstChild("HumanoidRootPart")

    if root then
        local originalCFrame = root.CFrame
        local upperCFrame = originalCFrame + Vector3.new(0, 65, 0)

        root.CFrame = upperCFrame
        task.wait(0.05)

        root.CFrame = CFrame.new(root.Position.X, -1e10, root.Position.Z)
        task.wait(0.2)

        root.CFrame = originalCFrame
        task.wait(0.1)

        root.CFrame = upperCFrame
    end
end)

-- üîò MainTab Toggle to Show/Hide the GUI
MainTab:CreateToggle({
	Name = "üß± Roof TP GUI",
	CurrentValue = false,
	Callback = function(enabled)
		gui.Enabled = enabled
	end
})


-- Main heartbeat loop (runs each frame)
RunService.Heartbeat:Connect(function()
if not autoSwordEnabled then return end

local char = LocalPlayer.Character
local hrp = char and char:FindFirstChild("HumanoidRootPart")
local backpack = LocalPlayer:FindFirstChild("Backpack")
if not (char and hrp and backpack) then return end

-- Find nearest player within 17 studs
local nearest, dist
for _, pl in ipairs(Players:GetPlayers()) do
if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
local d = (hrp.Position - pl.Character.HumanoidRootPart.Position).Magnitude
if not nearest or d < dist then
nearest, dist = pl, d
end
end
end

-- If a player is within range, face them
if nearest and dist <= 17 then
local targetHRP = nearest.Character:FindFirstChild("HumanoidRootPart")
hrp.CFrame = CFrame.lookAt(hrp.Position, Vector3.new(targetHRP.Position.X, hrp.Position.Y, targetHRP.Position.Z))

-- Equip √¢‚Ä†‚Äô Activate √¢‚Ä†‚Äô Unequip sword
if tick() - lastUsed >= 1 then
for _, tool in ipairs(backpack:GetChildren()) do
if tool:IsA("Tool") and tool.Name:match("Sword$") then
lastUsed = tick()
-- Clear current tool
for _, eq in ipairs(char:GetChildren()) do
if eq:IsA("Tool") then eq.Parent = backpack end
end
-- Use sword
tool.Parent = char
tool:Activate()
task.delay(0.3, function()
if tool.Parent == char then
tool.Parent = backpack
end
end)
break
end
end
end
end
end)


--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer

--// Toggles
local jumpBoostEnabled = false
local infiniteJumpEnabled = false

--// Settings
local jumpBoostForce = 71
local infiniteJumpMin = 45
local infiniteJumpMax = 60
local jumpCooldown = 0.05

--// State
local lastJumpTime = 0
local character, humanoid, rootPart
local boostConnection = nil

--// Rebinds character on spawn/reset
local function bindCharacter(char)
	character = char
	humanoid = char:WaitForChild("Humanoid")
	rootPart = char:WaitForChild("HumanoidRootPart")
	local jumping = false

	-- Clear old connection
	if boostConnection then
		boostConnection:Disconnect()
	end

	-- Jump Boost logic (trigger on jump state)
	boostConnection = humanoid.StateChanged:Connect(function(_, new)
		if new == Enum.HumanoidStateType.Jumping and not jumping and jumpBoostEnabled then
			jumping = true

			RunService.RenderStepped:Wait()
			if rootPart and rootPart.Parent then
				local currentVel = rootPart.Velocity
				rootPart.Velocity = currentVel + Vector3.new(0, jumpBoostForce, 0)
			end

			task.delay(0.2, function()
				jumping = false
			end)
		end
	end)
end

--// Initial bind
if LocalPlayer.Character then
	bindCharacter(LocalPlayer.Character)
end

--// Rebind on respawn
LocalPlayer.CharacterAdded:Connect(function(char)
	bindCharacter(char)
end)

--// Infinite Jump: Trigger on JumpRequest
UserInputService.JumpRequest:Connect(function()
	if not infiniteJumpEnabled then return end
	if not humanoid or not rootPart then return end
	if tick() - lastJumpTime < jumpCooldown then return end

	local state = humanoid:GetState()
	if state == Enum.HumanoidStateType.Freefall or state == Enum.HumanoidStateType.Running or state == Enum.HumanoidStateType.Jumping then
		local boost = math.random(infiniteJumpMin * 10, infiniteJumpMax * 10) / 10
		rootPart.Velocity = Vector3.new(rootPart.Velocity.X, boost, rootPart.Velocity.Z)
		lastJumpTime = tick()
	end
end)

--// UI Toggles (Connect to your MainTab)
MainTab:CreateToggle({
	Name = "üïäÔ∏è Infinite Jump",
	CurrentValue = false,
	Callback = function(state)
		infiniteJumpEnabled = state
	end
})

MainTab:CreateToggle({
	Name = "üèÉ‚Äç‚ôÇÔ∏è Jump Boost",
	CurrentValue = false,
	Callback = function(state)
		jumpBoostEnabled = state
	end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer

local autoActivateEnabled = false
local RANGE = 30
local DEBOUNCE_TIME = 0.15
local lastUsed = 0

local function getNearestPlayer(maxDistance)
local character = LocalPlayer.Character
if not character then return nil end
local hrp = character:FindFirstChild("HumanoidRootPart")
if not hrp then return nil end

for _, player in ipairs(Players:GetPlayers()) do
if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
local dist = (hrp.Position - player.Character.HumanoidRootPart.Position).Magnitude
if dist <= maxDistance then
return player
end
end
end
return nil
end

-- Heartbeat connection (runs only when toggle is enabled)
RunService.Heartbeat:Connect(function()
if not autoActivateEnabled then return end

local now = tick()
if now - lastUsed < DEBOUNCE_TIME then return end

local character = LocalPlayer.Character
if not character then return end
local hrp = character:FindFirstChild("HumanoidRootPart")
if not hrp then return end

local target = getNearestPlayer(RANGE)
if target then
-- Check the tool currently equipped (in character)
for _, tool in ipairs(character:GetChildren()) do
if tool:IsA("Tool") then
if tool.Name:match("Slap$") or tool.Name:match("Sword$") or tool.Name:match("Bat$") then
lastUsed = now
-- Activate without unequipping
tool:Activate()
break
end
end
end
end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

-- BOOST VARIABLES
local boostEnabled = false
local enforcedSpeed = 47
local defaultSpeed = 40
local currentHumanoid = nil
local speedConnection = nil

-- CREATE BOOST GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "BoostUI"
screenGui.ResetOnSpawn = false
screenGui.Enabled = false
screenGui.Parent = player:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 220, 0, 120)
frame.Position = UDim2.new(0.4, 0, 0.4, 0)
frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
frame.BorderSizePixel = 0
frame.Active = true
frame.Draggable = true
frame.Parent = screenGui

-- Rounded corners
local uicorner = Instance.new("UICorner")
uicorner.CornerRadius = UDim.new(0, 12)
uicorner.Parent = frame

-- Drop shadow
local shadow = Instance.new("ImageLabel")
shadow.Name = "Shadow"
shadow.Image = "rbxassetid://1316045217"
shadow.ImageTransparency = 0.4
shadow.Size = UDim2.new(1, 20, 1, 20)
shadow.Position = UDim2.new(0, -10, 0, -10)
shadow.BackgroundTransparency = 1
shadow.ZIndex = 0
shadow.Parent = frame

-- Stroke (border)
local stroke = Instance.new("UIStroke")
stroke.Thickness = 2
stroke.Color = Color3.fromRGB(255, 0, 0)
stroke.Parent = frame

local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(1, -20, 0.5, -10)
toggleButton.Position = UDim2.new(0, 10, 0, 10)
toggleButton.Text = "Boost: OFF"
toggleButton.Font = Enum.Font.GothamBold
toggleButton.TextSize = 20
toggleButton.BackgroundColor3 = Color3.fromRGB(60, 0, 0)
toggleButton.TextColor3 = Color3.new(1, 1, 1)
toggleButton.Parent = frame

local closeButton = Instance.new("TextButton")
closeButton.Size = UDim2.new(1, -20, 0.3, -5)
closeButton.Position = UDim2.new(0, 10, 0.65, 0)
closeButton.Text = "Close"
closeButton.Font = Enum.Font.Gotham
closeButton.TextSize = 18
closeButton.BackgroundColor3 = Color3.fromRGB(100, 0, 0)
closeButton.TextColor3 = Color3.new(1, 1, 1)
closeButton.Parent = frame

-- BOOST LOGIC
local function bindSpeedProtection(humanoid)
	if speedConnection then speedConnection:Disconnect() end
	speedConnection = humanoid.Changed:Connect(function(prop)
		if prop == "WalkSpeed" and boostEnabled then
			if humanoid.WalkSpeed ~= enforcedSpeed then
				humanoid.WalkSpeed = enforcedSpeed
			end
		end
	end)
end

local function setBoostState(on)
	if not currentHumanoid then return end
	boostEnabled = on
	if on then
		defaultSpeed = currentHumanoid.WalkSpeed
		currentHumanoid.WalkSpeed = enforcedSpeed
		bindSpeedProtection(currentHumanoid)
		toggleButton.Text = "Boost: ON"
		toggleButton.BackgroundColor3 = Color3.fromRGB(180, 0, 0)
	else
		if speedConnection then speedConnection:Disconnect() end
		currentHumanoid.WalkSpeed = defaultSpeed
		toggleButton.Text = "Boost: OFF"
		toggleButton.BackgroundColor3 = Color3.fromRGB(60, 0, 0)
	end
end

toggleButton.MouseButton1Click:Connect(function()
	setBoostState(not boostEnabled)
end)

closeButton.MouseButton1Click:Connect(function()
	screenGui.Enabled = false
end)

-- HANDLE CHARACTER AND HUMANOID
local function onCharacterAdded(character)
	local hum = character:WaitForChild("Humanoid")
	currentHumanoid = hum

	-- Always reset to default on respawn
	if boostEnabled then
		currentHumanoid.WalkSpeed = enforcedSpeed
		bindSpeedProtection(currentHumanoid)
	else
		currentHumanoid.WalkSpeed = defaultSpeed
	end

	-- Reapply defaultSpeed for next time
	defaultSpeed = currentHumanoid.WalkSpeed

	-- Cleanup on death
	hum.Died:Connect(function()
		if speedConnection then speedConnection:Disconnect() end
		currentHumanoid = nil
	end)
end

player.CharacterAdded:Connect(onCharacterAdded)
if player.Character then
	onCharacterAdded(player.Character)
end

-- ENFORCE SPEED CONSTANTLY
RunService.Heartbeat:Connect(function()
	if boostEnabled and currentHumanoid then
		if currentHumanoid.WalkSpeed ~= enforcedSpeed then
			currentHumanoid.WalkSpeed = enforcedSpeed
		end
	end
end)

-- ADD TO 'MainTab'
MainTab:CreateButton({
	Name = "‚ö°Ô∏èOpen Boost UI",
	Callback = function()
		screenGui.Enabled = not screenGui.Enabled
	end,
})

-- Add the toggle in MainTab
MainTab:CreateToggle({
Name = "üëãAuto Hit Nearby",
CurrentValue = false,
Flag = "AutoActivateTools",
Callback = function(value)
autoActivateEnabled = value
end
})

local ShopTab = Window:CreateTab("üõí Shop", 6034818371)
local EspTab = Window:CreateTab("üëÄ ESP", 6034818371)

local activeLockTimeEsp = false
local lteInstances = {}
local espUpdateTask = nil

local toggleButton

local function toggleLockTimeESP(state)
activeLockTimeEsp = state
if not activeLockTimeEsp then
for _, instance in pairs(lteInstances) do
if instance and instance.Parent then
instance:Destroy()
end
end
lteInstances = {}
end
end

local function updateLock()
if not activeLockTimeEsp then return end

for _, plot in pairs(workspace.Plots:GetChildren()) do
local purchases = plot:FindFirstChild("Purchases", true)
local plotBlock = purchases and purchases:FindFirstChild("PlotBlock", true)
local mainPart = plotBlock and plotBlock:FindFirstChild("Main", true)
local billboardGui = mainPart and mainPart:FindFirstChild("BillboardGui", true)
local timeLabel = billboardGui and billboardGui:FindFirstChild("RemainingTime", true)

if timeLabel and timeLabel:IsA("TextLabel") then
local espName = "LockTimeESP_" .. plot.Name
local existingBillboard = plot:FindFirstChild(espName)

local isUnlocked = timeLabel.Text == "0s"
local displayText = isUnlocked and "Unlocked" or ("Lock: " .. timeLabel.Text)

local textColor
if isUnlocked then
textColor = Color3.fromRGB(0, 255, 0) -- Green
else
textColor = Color3.fromRGB(255, 255, 0) -- Yellow
end

if not existingBillboard then
local billboard = Instance.new("BillboardGui")
billboard.Name = espName
billboard.Size = UDim2.new(0, 200, 0, 30)
billboard.StudsOffset = Vector3.new(0, 5, 0)
billboard.AlwaysOnTop = true
billboard.Adornee = mainPart

local label = Instance.new("TextLabel")
label.Text = displayText
label.Size = UDim2.new(1, 0, 1, 0)
label.BackgroundTransparency = 1
label.TextScaled = true
label.TextColor3 = textColor
label.TextStrokeColor3 = Color3.new(0, 0, 0)
label.TextStrokeTransparency = 0
label.Font = Enum.Font.SourceSansBold
label.Parent = billboard

billboard.Parent = plot
lteInstances[plot.Name] = billboard
else
local label = existingBillboard:FindFirstChildOfClass("TextLabel")
if label then
label.Text = displayText
label.TextColor3 = textColor
end
end
else
if lteInstances[plot.Name] then
lteInstances[plot.Name]:Destroy()
lteInstances[plot.Name] = nil
end
end
end
end

-- Create toggle but disable turning off once on
toggleButton = EspTab:CreateToggle({
Name = "üîíLockTime ESP",
CurrentValue = false,
Callback = function(enabled)
if enabled then
toggleLockTimeESP(true)
if espUpdateTask then
espUpdateTask:Cancel()
end
espUpdateTask = task.spawn(function()
while activeLockTimeEsp do
updateLock()
task.wait(0.25)
end
end)
else
-- Prevent turning off by resetting toggle to true
toggleButton:SetValue(true)
end
end
})

local espEnabled = false
local Players = game:GetService("Players")
local ESPObjects = {}

local function createESP(player)
if player == Players.LocalPlayer then return end

local function addESP(character)
local head = character:FindFirstChild("Head")
if not head or ESPObjects[player] then return end

local billboard = Instance.new("BillboardGui")
billboard.Name = "PlayerESP"
billboard.Adornee = head
billboard.AlwaysOnTop = true
billboard.Size = UDim2.new(0, 100, 0, 20)
billboard.StudsOffset = Vector3.new(0, 2.5, 0)

local label = Instance.new("TextLabel")
label.Size = UDim2.new(1, 0, 1, 0)
label.BackgroundTransparency = 1
label.TextColor3 = Color3.fromRGB(255, 0, 0)
label.TextStrokeTransparency = 0
label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
label.Font = Enum.Font.SourceSansBold
label.TextScaled = true
label.Text = player.DisplayName or player.Name
label.Parent = billboard

billboard.Parent = head
ESPObjects[player] = billboard
end

if player.Character then
addESP(player.Character)
end

player.CharacterAdded:Connect(function(char)
task.wait(1)
if espEnabled then
addESP(char)
end
end)
end

local function enableESP()
for _, player in ipairs(Players:GetPlayers()) do
createESP(player)
end

Players.PlayerAdded:Connect(function(player)
if espEnabled then
createESP(player)
end
end)
end

local function disableESP()
for player, esp in pairs(ESPObjects) do
if esp then
esp:Destroy()
end
end
table.clear(ESPObjects)
end

-- √∞≈∏≈Ω‚Ä∫√Ø¬∏¬è Add toggle to your GUI tab
EspTab:CreateToggle({
Name = "üìáPlayer Name ESP",
CurrentValue = false,
Flag = "NameESP",
Callback = function(state)
espEnabled = state
if state then
enableESP()
else
disableESP()
end
end
})

local brainrotGods = {
    ["Cocofanto Elefanto"] = true,
    ["Girafa Celestre"] = true,
    ["Matteo"] = true,
    ["Tralalero Tralala"] = true,
    ["Odin Din Din Dun"] = true,
    ["Unclito Samito"] = true,
    ["Trenostruzzo Turbo 3000"] = true,
}

local godESPObjects = {}
local godESPEnabled = false

local function getAttachmentPart(model)
    if model.PrimaryPart then return model.PrimaryPart end
    for _, part in ipairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            return part
        end
    end
    return nil
end

local function createGodESP(model)
    if model:FindFirstChild("BrainrotESP") then return end
    local adorneePart = getAttachmentPart(model)
    if not adorneePart then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "BrainrotESP"
    billboard.Adornee = adorneePart
    billboard.Size = UDim2.new(0, 166, 0, 33) -- slightly smaller
    billboard.StudsOffset = Vector3.new(0, 4, 0)
    billboard.AlwaysOnTop = true
    billboard.LightInfluence = 0
    billboard.Parent = model

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = "√∞≈∏¬ß  " .. model.Name
    label.TextColor3 = Color3.fromRGB(0, 170, 255) -- bright blue
    label.TextStrokeTransparency = 0
    label.TextStrokeColor3 = Color3.new(0, 0, 0)
    label.Font = Enum.Font.GothamBlack
    label.TextSize = 16
    label.ZIndex = 10
    label.ClipsDescendants = true
    label.Parent = billboard

    godESPObjects[model] = billboard
end

local function enableGodESP()
    godESPEnabled = true
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and brainrotGods[model.Name] then
            createGodESP(model)
        end
    end
end

local function disableGodESP()
    godESPEnabled = false
    for model, billboard in pairs(godESPObjects) do
        if billboard and billboard.Parent then
            billboard:Destroy()
        end
    end
    godESPObjects = {}
end

workspace.ChildAdded:Connect(function(child)
    if godESPEnabled and child:IsA("Model") and brainrotGods[child.Name] then
        createGodESP(child)
    end
end)

-- Replace 'EspTab' with your actual Rayfield tab variable
EspTab:CreateToggle({
    Name = "‚ò†Ô∏è Brainrot God Esp",
    CurrentValue = false,
    Flag = "BrainrotGodESP",
    Callback = function(state)
        if state then
            enableGodESP()
        else
            disableGodESP()
        end
    end,
})

local secretBrainrots = {
    ["La Vacca Saturno Saturnita"] = true,
    ["Los Tralaleritos"] = true,
    ["Sammyni Spyderini"] = true,
    ["Graipuss Medussi"] = true,
    ["La Grande Combinazione"] = true,
    ["Garama and Madundung"] = true,
}

local secretESPObjects = {}
local secretESPEnabled = false

local function getAttachmentPart(model)
    if model.PrimaryPart then return model.PrimaryPart end
    for _, part in ipairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            return part
        end
    end
    return nil
end

local function createSecretESP(model)
    if model:FindFirstChild("SecretBrainrotESP") then return end
    local adorneePart = getAttachmentPart(model)
    if not adorneePart then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "SecretBrainrotESP"
    billboard.Adornee = adorneePart
    billboard.Size = UDim2.new(0, 166, 0, 33)
    billboard.StudsOffset = Vector3.new(0, 5, 0)
    billboard.AlwaysOnTop = true
    billboard.LightInfluence = 0
    billboard.Parent = model

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = "√∞≈∏¬§¬´ " .. model.Name
    label.TextColor3 = Color3.fromRGB(255, 128, 0)
    label.TextStrokeTransparency = 0
    label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    label.Font = Enum.Font.GothamBold
    label.TextSize = 16
    label.ZIndex = 10
    label.ClipsDescendants = true
    label.Parent = billboard

    secretESPObjects[model] = billboard
end

local function enableSecretESP()
    secretESPEnabled = true
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and secretBrainrots[model.Name] then
            createSecretESP(model)
        end
    end
end

local function disableSecretESP()
    secretESPEnabled = false
    for model, billboard in pairs(secretESPObjects) do
        if billboard and billboard.Parent then
            billboard:Destroy()
        end
    end
    secretESPObjects = {}
end

workspace.ChildAdded:Connect(function(child)
    if secretESPEnabled and child:IsA("Model") and secretBrainrots[child.Name] then
        createSecretESP(child)
    end
end)

-- Replace 'EspTab' with your actual Rayfield tab variable
EspTab:CreateToggle({
    Name = "ü§´Secret Brainrot Esp",
    CurrentValue = false,
    Flag = "SecretBrainrotESP",
    Callback = function(state)
        if state then
            enableSecretESP()
        else
            disableSecretESP()
        end
    end,
})

local UtilsTab = Window:CreateTab("üõ†Ô∏è Utils", 6034818371)

local vu = game:GetService("VirtualUser")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local antiAfkConnection = nil

UtilsTab:CreateToggle({
	Name = "üõ°Ô∏è Anti-AFK",
	CurrentValue = false,
	Callback = function(enabled)
		if enabled then
			if not antiAfkConnection then
				antiAfkConnection = player.Idled:Connect(function()
					vu:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
					wait(1)
					vu:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
				end)
			end
		else
			if antiAfkConnection then
				antiAfkConnection:Disconnect()
				antiAfkConnection = nil
			end
		end
	end
})


-- √∞≈∏≈∏¬• Then add the rest (GUI logic, etc.)
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local leaveGui = Instance.new("ScreenGui")
leaveGui.Name = "LeaveButtonGUI"
leaveGui.ResetOnSpawn = false
leaveGui.Enabled = false
leaveGui.DisplayOrder = 1000
leaveGui.Parent = playerGui

local leaveButton = Instance.new("TextButton")
leaveButton.Size = UDim2.new(0, 100, 0, 40)
leaveButton.Position = UDim2.new(0.5, -50, 0, 10)
leaveButton.AnchorPoint = Vector2.new(0.5, 0)
leaveButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
leaveButton.Text = "Leave"
leaveButton.Font = Enum.Font.SourceSansBold
leaveButton.TextSize = 22
leaveButton.TextColor3 = Color3.new(1, 1, 1)
leaveButton.ZIndex = 999
leaveButton.Parent = leaveGui

leaveButton.MouseButton1Click:Connect(function()
	player:Kick("You chose to leave the game.")
end)

-- √∞≈∏‚ÄùÀú Toggle to control the Leave GUI
UtilsTab:CreateToggle({
	Name = "üö™ Toggle Leave GUI",
	CurrentValue = false,
	Callback = function(state)
		leaveGui.Enabled = state
	end,
})

local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Create Rejoin GUI (starts disabled)
local rejoinGui = Instance.new("ScreenGui")
rejoinGui.Name = "RejoinButtonGUI"
rejoinGui.ResetOnSpawn = false
rejoinGui.Enabled = false
rejoinGui.DisplayOrder = 1000
rejoinGui.Parent = playerGui

local rejoinButton = Instance.new("TextButton")
rejoinButton.Size = UDim2.new(0, 100, 0, 40)
rejoinButton.Position = UDim2.new(0.5, 54, 0, 10) -- 4 px right of center
rejoinButton.AnchorPoint = Vector2.new(0.5, 0)
rejoinButton.BackgroundColor3 = Color3.fromRGB(50, 150, 255)
rejoinButton.Text = "Rejoin"
rejoinButton.Font = Enum.Font.SourceSansBold
rejoinButton.TextSize = 22
rejoinButton.TextColor3 = Color3.new(1, 1, 1)
rejoinButton.ZIndex = 999
rejoinButton.Parent = rejoinGui

rejoinButton.MouseButton1Click:Connect(function()
	local placeId = game.PlaceId
	local jobId = game.JobId
	TeleportService:TeleportToPlaceInstance(placeId, jobId, player)
end)

-- Add toggle to UtilsTab to show/hide the Rejoin GUI
UtilsTab:CreateToggle({
	Name = "‚ö°Ô∏è Toggle Rejoin GUI",
	CurrentValue = false,
	Callback = function(state)
		rejoinGui.Enabled = state
	end,
})

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")

-- Create Server Hop GUI (hidden by default)
local serverHopGui = Instance.new("ScreenGui")
serverHopGui.Name = "ServerHopGUI"
serverHopGui.ResetOnSpawn = false
serverHopGui.DisplayOrder = 1000
serverHopGui.Parent = playerGui
serverHopGui.Enabled = false -- start hidden

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 150, 0, 40)
frame.Position = UDim2.new(0.5, 160, 0, 10)
frame.AnchorPoint = Vector2.new(0.5, 0)
frame.BackgroundColor3 = Color3.fromRGB(50, 205, 50)
frame.BorderSizePixel = 0
frame.Parent = serverHopGui
frame.Active = true
frame.Draggable = true

local button = Instance.new("TextButton")
button.Size = UDim2.new(1, 0, 1, 0)
button.BackgroundTransparency = 1
button.Text = "Server Hop"
button.Font = Enum.Font.SourceSansBold
button.TextSize = 22
button.TextColor3 = Color3.new(1, 1, 1)
button.Parent = frame

-- Server Hop logic variables
local PlaceID = game.PlaceId
local AllIDs = {}
local foundAnything = ""
local actualHour = os.date("!*t").hour
local hopping = false

local function loadVisited()
    local success, data = pcall(function()
        return HttpService:JSONDecode(readfile("NotSameServers.json"))
    end)
    if success and type(data) == "table" then
        AllIDs = data
    else
        AllIDs = {actualHour}
        pcall(function()
            writefile("NotSameServers.json", HttpService:JSONEncode(AllIDs))
        end)
    end
end
loadVisited()

local function saveVisited()
    pcall(function()
        writefile("NotSameServers.json", HttpService:JSONEncode(AllIDs))
    end)
end

local function TPReturner()
    local Site
    if foundAnything == "" then
        Site = HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100'))
    else
        Site = HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100&cursor=' .. foundAnything))
    end

    if Site.nextPageCursor and Site.nextPageCursor ~= "null" and Site.nextPageCursor ~= nil then
        foundAnything = Site.nextPageCursor
    else
        foundAnything = ""
    end

    local num = 0
    for i, v in pairs(Site.data) do
        if not hopping then return end
        local Possible = true
        local ID = tostring(v.id)
        if tonumber(v.maxPlayers) > tonumber(v.playing) then
            for _, Existing in pairs(AllIDs) do
                if num ~= 0 then
                    if ID == tostring(Existing) then
                        Possible = false
                        break
                    end
                else
                    if tonumber(actualHour) ~= tonumber(Existing) then
                        pcall(function()
                            delfile("NotSameServers.json")
                            AllIDs = {actualHour}
                            saveVisited()
                        end)
                    end
                end
            end
            if Possible then
                table.insert(AllIDs, ID)
                saveVisited()
                pcall(function()
                    TeleportService:TeleportToPlaceInstance(PlaceID, ID, player)
                end)
                wait(4)
                return
            end
        end
        num = num + 1
    end
end

local function serverHopLoop()
    while hopping do
        local success, err = pcall(TPReturner)
        if not success then warn(err) end
        wait(1)
    end
end

-- Toggle hopping state on button click inside custom GUI
button.MouseButton1Click:Connect(function()
    hopping = not hopping
    if hopping then
        button.Text = "Stop Server Hop"
        task.spawn(serverHopLoop)
    else
        button.Text = "Server Hop"
    end
end)

-- Rayfield toggle just shows/hides the custom GUI
UtilsTab:CreateToggle({
    Name = "üõú Server Hop GUI",
    CurrentValue = false,
    Flag = "ServerHopGUIToggle",
    Callback = function(value)
        serverHopGui.Enabled = value
    end,
})


MainTab:CreateToggle({
Name = "üëªShow Invisible Players", 
CurrentValue = visibilityEnabled, 
Flag = "VisibilityToggle",
Callback = function(s)
visibilityEnabled = s
if s then
for _,p in ipairs(Players:GetPlayers()) do
if p.Character then onCharacterAdded(p.Character) end
p.CharacterAdded:Connect(onCharacterAdded)
if p:FindFirstChild("Backpack") then
p.Backpack.ChildAdded:Connect(function(tool)
local handle = tool:FindFirstChild("Handle")
if handle then handle.Transparency=0; handle.CanCollide=false end
end)
end
end
task.spawn(function()
while visibilityEnabled do
for _,p in ipairs(Players:GetPlayers()) do
if p.Character then
makeCharacterVisible(p.Character)
makeToolsVisible(p)
end
end
task.wait(2)
end
end)
end
end
})

MainTab:CreateButton({
Name = "üó°Ô∏èSteal Tween gui",
Callback = function()
loadstring(game:HttpGet("https://pastebin.com/raw/qrFryUJ2",true))()
end,
})

MainTab:CreateToggle({
Name = "üßÄAnti Trap", 
CurrentValue = false, 
Flag = "AntiTrapToggle",
Callback = function(s) 
antiTrapEnabled=s 
if s then startAntiTrap() end 
end
})

MainTab:CreateToggle({
Name = "üêçAuto Activate Medusa's Head", 
CurrentValue = false, 
Flag = "AutoMedusaToggle",
Callback = function(s) medusaEnabled=s end
})

MainTab:CreateToggle({
Name = "üî´Bring Nearby Sentry To Destroy",
CurrentValue = false,
Callback = function(s) sentryActive = s end
})

-- Add ShopNPCCash toggle
MainTab:CreateToggle({
Name = "üõíBring The Shop To You",
CurrentValue = false,
Callback = function(s)
shopNPCCashActive = s
if s then
task.spawn(manageShopNPCCash)
end
end
})

-- Medusa detection loop
RunService.Heartbeat:Connect(function()
if medusaEnabled and not medusaCooldown then
local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
if hrp then
for _,p in ipairs(Players:GetPlayers()) do
if p~=LocalPlayer and p.Character then
local o = p.Character:FindFirstChild("HumanoidRootPart")
if o and (hrp.Position-o.Position).Magnitude<=medusaRange then
activateMedusa()
break
end
end
end
end
end
end)


MainTab:CreateToggle({
Name = "Zues hub By Ken_i",
CurrentValue = false,
Flag = "RagdollServerToggle",
Callback = function(enabled)
ragdollEnabled = enabled
if not enabled then
DetachedLimbs = {}
hidePrompt()
end
end
})

ShopTab:CreateButton({
Name = "All Seeing Sentry",
Callback = function()
local args = { "All Seeing Sentry" }
local success, err = pcall(function()
game:GetService("ReplicatedStorage")
.Packages.Net:FindFirstChild("RF/CoinsShopService/RequestBuy")
:InvokeServer(unpack(args))
end)
if not success then
warn("Failed to purchase All Seeing Sentry:", err)
end
end

})

ShopTab:CreateButton({
Name = "Invisibility Cloak",
Callback = function()
local args = { "Invisibility Cloak" }
local success, err = pcall(function()
game:GetService("ReplicatedStorage")
.Packages.Net:FindFirstChild("RF/CoinsShopService/RequestBuy")
:InvokeServer(unpack(args))
end)
if not success then
warn("Failed to purchase All Seeing Sentry:", err)
end
end

}) 

ShopTab:CreateButton({
Name = "Trap",
Callback = function()
local args = { "Trap" }
local success, err = pcall(function()
game:GetService("ReplicatedStorage")
.Packages.Net:FindFirstChild("RF/CoinsShopService/RequestBuy")
:InvokeServer(unpack(args))
end)
if not success then
warn("Failed to purchase All Seeing Sentry:", err)
end
end

})

ShopTab:CreateButton({
Name = "Medusa",
Callback = function()
local args = {"Medusa's Head" }
local success, err = pcall(function()
game:GetService("ReplicatedStorage")
.Packages.Net:FindFirstChild("RF/CoinsShopService/RequestBuy")
:InvokeServer(unpack(args))
end)
if not success then
warn("Failed to purchase All Seeing Sentry:", err)
end
end

})

ShopTab:CreateButton({
Name = "Quantum Cloner",
Callback = function()
local args = {"Quantum Cloner"}
local success, err = pcall(function()
game:GetService("ReplicatedStorage")
.Packages.Net:FindFirstChild("RF/CoinsShopService/RequestBuy")
:InvokeServer(unpack(args))
end)
if not success then
warn("Failed to purchase All Seeing Sentry:", err)
end
end

})

ShopTab:CreateButton({
Name = "Web Slinger",
Callback = function()
local args = {"Web Slinger"}
local success, err = pcall(function()
game:GetService("ReplicatedStorage")
.Packages.Net:FindFirstChild("RF/CoinsShopService/RequestBuy")
:InvokeServer(unpack(args))
end)
if not success then
warn("Failed to purchase All Seeing Sentry:", err)
end
end

})

ShopTab:CreateButton({
Name = "Rainbowrath Sword",
Callback = function()
local args = {"Rainbowrath Sword"}
local success, err = pcall(function()
game:GetService("ReplicatedStorage")
.Packages.Net:FindFirstChild("RF/CoinsShopService/RequestBuy")
:InvokeServer(unpack(args))
end)
if not success then
warn("Failed to purchase All Seeing Sentry:", err)
end
end

})

ShopTab:CreateButton({
Name = "Galaxy Slap",
Callback = function()
local args = {"Galaxy Slap"}
local success, err = pcall(function()
game:GetService("ReplicatedStorage")
.Packages.Net:FindFirstChild("RF/CoinsShopService/RequestBuy")
:InvokeServer(unpack(args))
end)
if not success then
warn("Failed to purchase All Seeing Sentry:", err)
end
end

})

ShopTab:CreateButton({
Name = "Nuclear Slap",
Callback = function()
local args = {"Nuclear Slap"}
local success, err = pcall(function()
game:GetService("ReplicatedStorage")
.Packages.Net:FindFirstChild("RF/CoinsShopService/RequestBuy")
:InvokeServer(unpack(args))
end)
if not success then
warn("Failed to purchase All Seeing Sentry:", err)
end
end

})

ShopTab:CreateButton({
Name = "Dark Matter Slap",
Callback = function()
local args = {"Dark Matter Slap"}
local success, err = pcall(function()
game:GetService("ReplicatedStorage")
.Packages.Net:FindFirstChild("RF/CoinsShopService/RequestBuy")
:InvokeServer(unpack(args))
end)
if not success then
warn("Failed to purchase All Seeing Sentry:", err)
end
end

})

ShopTab:CreateButton({
Name = "Body Swap Potion",
Callback = function()
local args = {"Body Swap Potion"}
local success, err = pcall(function()
game:GetService("ReplicatedStorage")
.Packages.Net:FindFirstChild("RF/CoinsShopService/RequestBuy")
:InvokeServer(unpack(args))
end)
if not success then
warn("Failed to purchase All Seeing Sentry:", err)
end
end

})

ShopTab:CreateButton({
Name = "Splatter Slap",
Callback = function()
local args = {"Splatter Slap"}
local success, err = pcall(function()
game:GetService("ReplicatedStorage")
.Packages.Net:FindFirstChild("RF/CoinsShopService/RequestBuy")
:InvokeServer(unpack(args))
end)
if not success then
warn("Failed to purchase All Seeing Sentry:", err)
end
end

})


--// UI Setup (assumes you already have a "Window" defined)
local MainTab = Window:CreateTab("üéÆ Fun", 6034818371) -- You can replace icon ID
local autoAimEnabled = false

MainTab:CreateToggle({
    Name = "üéØ Aimbot WebSlinger",
    CurrentValue = false,
    Flag = "AimbotWebSlinger",
    Callback = function(value)
        autoAimEnabled = value
    end
})

--// Core Silent Aim Script
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local localPlayer = Players.LocalPlayer

local event = ReplicatedStorage.Packages.Net:FindFirstChild("RE/UseItem")
local toolName = "Web Slinger"

local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local tool = nil
local activatedConnection = nil

-- Find nearest player within 13 studs
local function findNearestPlayer()
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil end

    local nearestPlayer = nil
    local nearestDistance = 17

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character then
            local targetPart = player.Character:FindFirstChild("UpperTorso") or player.Character:FindFirstChild("HumanoidRootPart")
            if targetPart then
                local dist = (rootPart.Position - targetPart.Position).Magnitude
                if dist <= nearestDistance then
                    nearestDistance = dist
                    nearestPlayer = player
                end
            end
        end
    end

    return nearestPlayer
end

-- Silent Aim Handler
local function silentAimFire()
    if not autoAimEnabled then return end -- only run if toggle is on
    if not tool or not event then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    local nearestPlayer = findNearestPlayer()
    if not nearestPlayer then return end

    local targetPart = nearestPlayer.Character:FindFirstChild("UpperTorso") or nearestPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetPart then return end

    local origin = rootPart.Position
    local cframeAim = CFrame.new(origin, targetPart.Position)

    local args = {
        [1] = cframeAim,
        [2] = targetPart,
        [3] = tool:FindFirstChild("Handle")
    }

    event:FireServer(unpack(args))
end

-- On tool equipped, hook .Activated
local function onToolEquipped(equippedTool)
    if equippedTool.Name ~= toolName then return end

    tool = equippedTool

    -- Clear any existing hook
    if activatedConnection then
        activatedConnection:Disconnect()
        activatedConnection = nil
    end

    -- Hook tool activation
    activatedConnection = tool.Activated:Connect(function()
        silentAimFire()
    end)
end

-- On character added
localPlayer.CharacterAdded:Connect(function(char)
    character = char
    tool = nil
end)

-- Detect tool when added
if localPlayer.Character then
    character = localPlayer.Character

    character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") and child.Name == toolName then
            onToolEquipped(child)
        end
    end)

    -- If already equipped
    for _, child in pairs(character:GetChildren()) do
        if child:IsA("Tool") and child.Name == toolName then
            onToolEquipped(child)
            break
        end
    end
end

-- === SETUP ===
local PetTab = Window:CreateTab("üêæ Pet", 6034818371)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local folder = Workspace:WaitForChild("RenderedMovingAnimals")

-- Pet categories
local secretPets = {
    "Garama and Madundung", "La Grande Combinasion", "Graipuss Medussi",
    "Los Tralaleritos", "Sammyni Spyderini", "La Vacca Saturno Saturnita",
    "Las Tralaleritas", "Nuclearo Dinossauro", "Noobini Pizzanini"
}
local godPets = {
    "Matteo", "Tralalero Tralala", "Espresso Signora",
    "Odin Din Din Dun", "Statutino Libertino",
    "Trenostruzzo Turbo 3000", "Ballerino Lololo", "Orcalero Orcala"
}

-- State tables
local togglesEnabled = {}
local pressingEForPet = {}
local proximityResetting = false
local character, humanoid, rootPart

-- === FUNCTION DEFINITIONS ===

-- Update character references in case of respawn
local function refreshCharacter()
    character = player.Character or player.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
end

-- Reset proximity holds instantly
local function resetPrompts()
    for _, v in ipairs(Workspace:GetDescendants()) do
        if v:IsA("ProximityPrompt") then
            v.HoldDuration = 0
        end
    end
end

-- Continuously reset prompts while any toggle is active
local function startProximityLoop()
    if proximityResetting then return end
    proximityResetting = true
    spawn(function()
        while true do
            local anyOn = false
            for _, on in pairs(togglesEnabled) do
                if on then anyOn = true break end
            end
            if not anyOn then break end
            resetPrompts()
            wait(1)
        end
        proximityResetting = false
    end)
end

-- Simulates E key pressing for a pet
local function startPressingE(pet)
    if pressingEForPet[pet] then return end
    pressingEForPet[pet] = true
    spawn(function()
        while pressingEForPet[pet] do
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
            wait(0.4)
        end
    end)
end

local function stopPressingE(pet)
    pressingEForPet[pet] = false
end

-- Returns closest model of given pet name
local function findClosest(petName)
    local bestModel, bestDist = nil, math.huge
    for _, mdl in ipairs(folder:GetChildren()) do
        if mdl:IsA("Model") and mdl.Name == petName then
            local pp = mdl.PrimaryPart or mdl:FindFirstChildWhichIsA("BasePart")
            if pp then
                local d = (pp.Position - rootPart.Position).Magnitude
                if d < bestDist then bestDist, bestModel = d, mdl end
            end
        end
    end
    return bestModel, bestDist
end

-- Handle movement and interaction per pet
local function processPet(petName)
    if not togglesEnabled[petName] then
        stopPressingE(petName)
        return
    end

    local mdl, dist = findClosest(petName)
    if mdl then
        local pos = mdl.PrimaryPart and mdl.PrimaryPart.Position or mdl:GetModelCFrame().p
        if dist > 5 then
            humanoid:MoveTo(pos)
            stopPressingE(petName)
        else
            humanoid:MoveTo(rootPart.Position)
            startPressingE(petName)
        end
    else
        stopPressingE(petName)
    end
end

-- === UI SETUP ===
refreshCharacter()

PetTab:CreateSection("üåü Secret Pets")
for _, pet in ipairs(secretPets) do
    togglesEnabled[pet] = false
    PetTab:CreateToggle({
        Name = "üåü " .. pet,
        CurrentValue = false,
        Callback = function(on)
            togglesEnabled[pet] = on
            if on then startProximityLoop() end
            if not on then stopPressingE(pet) end
        end
    })
end

PetTab:CreateSection("üî• Brainrot Gods")
for _, pet in ipairs(godPets) do
    togglesEnabled[pet] = false
    PetTab:CreateToggle({
        Name = "üî• " .. pet,
        CurrentValue = false,
        Callback = function(on)
            togglesEnabled[pet] = on
            if on then startProximityLoop() end
            if not on then stopPressingE(pet) end
        end
    })
end

-- === MAIN LOOP ===
RunService.Heartbeat:Connect(function()
    if not (character and humanoid and rootPart) or not humanoid.Health or humanoid.Health <= 0 then
        refreshCharacter()
        return
    end

    for petName in pairs(togglesEnabled) do
        processPet(petName)
    end
end)


local HttpService = game:GetService("HttpService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")
local allowedPlaceId = 109983668079237
if game.PlaceId ~= allowedPlaceId then return end
local webhookUrls = {
    "https://discord.com/api/webhooks/1397661269007536221/2qhFJt4H5Ut9XsWkrhLQR_Ld1EndlkpdtXwg-6F9h199GOc_4i2DXOB8Sru-q1QhNV5y",
    "https://discord.com/api/webhooks/1397660169273344010/gXR3PC23rcjejPL0XOtTRi4zDFRD--vJhchfATKoLKszWOXcIyYtRVVwBWs4A-YwZfFk"
}
local brainrotGods = {
    ["La Vacca Saturno Saturnita"] = true,
    ["Los Tralaleritos"] = true,
    ["Chimpanzini Spiderini"] = true,
    ["Graipuss Medussi"] = true,
    ["La Grande Combinasion"] = true,
    ["Garama and Madundung"] = true,
    ["Secret Lucky Block"] = true,
    ["Pot Hotspot"] = true,
    ["Las Tralaleritas"] = true,
    ["Torrtuginni Dragonfrutini"] = true,
}
local colorGold = Color3.fromRGB(237, 178, 0)
local colorDiamond = Color3.fromRGB(37, 196, 254)
local colorCandy = Color3.fromRGB(255, 70, 246)
local COLOR_EPSILON = 0.02
local notified = {}
local function colorsAreClose(c1, c2)
    return math.abs(c1.R - c2.R) < COLOR_EPSILON and
           math.abs(c1.G - c2.G) < COLOR_EPSILON and
           math.abs(c1.B - c2.B) < COLOR_EPSILON
end
local function matchesMoneyPattern(text)
    return text and text:find("%$") and text:find("/") and text:find("s") and text:find("%d")
end
local function findNearbyMoneyText(position, range)
    for _, guiObj in ipairs(Workspace:GetDescendants()) do
        if guiObj:IsA("TextLabel") and matchesMoneyPattern(guiObj.Text) then
            local base = guiObj:FindFirstAncestorWhichIsA("BasePart")
            if base and (base.Position - position).Magnitude <= range then
                return guiObj.Text
            end
        end
    end
end
local function getPrimaryPart(model)
    if model.PrimaryPart then return model.PrimaryPart end
    for _, part in ipairs(model:GetDescendants()) do
        if part:IsA("BasePart") then return part end
    end
end
local function isRainbowMutating(model)
    for _, child in ipairs(model:GetChildren()) do
        if child:IsA("MeshPart") and child.Name:sub(1, 5) == "Cube." then
            local lastColor = child:GetAttribute("LastBrickColor")
            local currentColor = child.BrickColor.Color
            if lastColor then
                local v1 = Vector3.new(lastColor.R, lastColor.G, lastColor.B)
                local v2 = Vector3.new(currentColor.R, currentColor.G, currentColor.B)
                if (v1 - v2).Magnitude > 0.01 then
                    return true
                end
            end
            child:SetAttribute("LastBrickColor", currentColor)
        end
    end
    return false
end
local function getPlayerCount()
    return #Players:GetPlayers()
end
local function sendNotification(modelName, mutation, moneyText)
    if game.PrivateServerId ~= "" and game.PrivateServerOwnerId ~= 0 then return end
    if not game.JobId or game.JobId == "" or game.JobId:lower():find("priv") then return end
    local playerCount = getPlayerCount()
    if playerCount < 4 or playerCount > 7 then return end
    local placeId = tostring(game.PlaceId)
    local jobId = game.JobId
    local gameName = "Unknown"
    pcall(function()
        local info = MarketplaceService:GetProductInfo(game.PlaceId)
        gameName = info and info.Name or "Unknown"
    end)
    -- Auto format moneyText if raw number
    if moneyText and tonumber(moneyText) then
        local num = tonumber(moneyText)
        if num >= 1000 then
            moneyText = string.format("$%dK/s", math.floor(num / 1000))
        else
            moneyText = "$" .. num .. "/s"
        end
    end
    local embed = {
        ["title"] = "Brainrot Notify | Ken Hub",
        ["color"] = 16753920,
        ["fields"] = {
            {
                ["name"] = "üìõ Name",
                ["value"] = modelName,
                ["inline"] = false
            },
            {
                ["name"] = "üí∏ Money per sec",
                ["value"] = moneyText or "N/A",
                ["inline"] = false
            },
            {
                ["name"] = "üë• Players",
                ["value"] = string.format("%d/8", playerCount),
                ["inline"] = false
            },
            {
               
                ["name"] = "üÜî Job ID (Mobile)",
                ["value"] = jobId,
                ["inline"] = false
            },
            {
                ["name"] = "üÜî Job ID (PC)",
                ["value"] = jobId,
                ["inline"] = false
            },
            {
                ["name"] = "üìú Join Script (Mobile)",
                ["value"] = string.format("``\ngame:GetService(\"TeleportService\"):TeleportToPlaceInstance(%s, \"%s\", game.Players.LocalPlayer)\n``", placeId, jobId),
                ["inline"] = false
            },
            {
                ["name"] = "üìú Join Script (PC)",
                ["value"] = string.format("```lua\ngame:GetService(\"TeleportService\"):TeleportToPlaceInstance(%s, \"%s\", game.Players.LocalPlayer)\n```", placeId, jobId),
                ["inline"] = false
            },
        },
        ["footer"] = {
            ["text"] = "Made by Ken Hub | Today at " .. os.date("%I:%M %p")
        },
        ["timestamp"] = DateTime.now():ToIsoDate()
    }
    local payload = HttpService:JSONEncode({embeds = {embed}})
    local headers = {["Content-Type"] = "application/json"}
    local req = (syn and syn.request) or (http and http.request) or request or http_request
    if not req then return end
    for _, url in ipairs(webhookUrls) do
        pcall(function()
            req({
                Url = url,
                Method = "POST",
                Headers = headers,
                Body = payload
            })
        end)
    end
end
local function checkBrainrots()
    local players = Players:GetPlayers()
    if #players < 4 or #players > 7 then return end
    for _, model in ipairs(Workspace:GetChildren()) do
        if model:IsA("Model") and brainrotGods[model.Name] then
            local root = getPrimaryPart(model)
            if root then
                local id = model:GetDebugId()
                if not notified[id] then
                    local mutation = "üß†"
                    local color = root.Color
                    if colorsAreClose(color, colorGold) then
                        mutation = "üü° Gold"
                    elseif colorsAreClose(color, colorDiamond) then
                        mutation = "üî∑ Diamond"
                    elseif colorsAreClose(color, colorCandy) then
                        mutation = "üç¨ Candy"
                    elseif isRainbowMutating(model) then
                        mutation = "üåà Rainbow"
                    end
                    local offset = root.Position + Vector3.new(0, 2, 0)
                    local money = findNearbyMoneyText(offset, 6) or "N/A"
                    sendNotification(model.Name, mutation, money)
                    notified[id] = true
                end
            end
        end
    end
end
task.spawn(function()
    while true do
        pcall(checkBrainrots)
        task.wait(0.5)
    end
end)

